{
  "entry": "\n   ",
  "title": "Leveling the Field",
  "link": "http://blog.basho.com/2011/07/01/Leveling-the-Field",
  "guid": "http://blog.basho.com/2011/07/01/Leveling-the-Field",
  "updated": "2011-07-01T00:00:00+00:00",
  "pubdate": "2011-07-01T07:00:00.000Z",
  "rfc822": "Fri, 01 Jul 2011 00:00:00 -0700",
  "id": "http://blog.basho.com/2011/07/01/Leveling-the-Field",
  "description": "<p><strong>July 1, 2011</strong></p>\n<p>For most Riak users, <a href=\"http://blog.basho.com/2010/04/27/hello-bitcask/\">Bitcask</a> is the obvious right storage engine to use.  It provides low latency, solid predictability, is robust in the face of crashes, and is friendly from a filesystem backup point of view.  However, it has one notable limitation: total <span class=\"caps\">RAM</span> use depends linearly (though via a small constant) on the total number of objects stored.  For this reason, Riak users that need to store billions of entries per machine sometimes use <a href=\"https://github.com/basho/innostore#readme\">Innostore</a> (our wrapper around embedded InnoDB) as their storage engine instead.  InnoDB is a robust and well-known storage engine, and uses a more traditional design than Bitcask which allows it to tolerate a higher maximum number of items stored on a given host.</p>\n<p>However, there are a number of reasons that people may wish for something other than Innostore when they find that they are in this situation.  It is less comfortable to back up than bitcask, imposes a higher minimum overhead on disk space, only performs well when both heavily tuned (and given multiple spindles), and comes with a more restrictive license.  For all of these reasons we have been paying close attention to <a href=\"http://code.google.com/p/leveldb/\">LevelDB</a>, which was recently released by Google.  LevelDB&#8217;s storage architecture is more like BigTable&#8217;s memtable/sstable model than it is like either Bitcask or InnoDB.  This design and implementation brings the possibility of a storage engine without Bitcask&#8217;s <span class=\"caps\">RAM</span> limitation and also without any of the above drawbacks of InnoDB. Our early hypothesis after reading the text and code was that LevelDB might fill an InnoDB-like role for Riak users, without some of the downsides. As some of the early bugs in LevelDB were fixed and stability improved, our hopes rose further.</p>\n<p>In order to begin testing this possibility, we have begun to perform some simple performance comparisons between LevelDB and InnoDB using <a href=\"https://github.com/basho/basho_bench#readme\">basho_bench</a> and a few different usage patterns. All of these comparisons were performed on the exact same machine, a fairly basic 2-<span class=\"caps\">CPU</span> Linux server with 4G of <span class=\"caps\">RAM</span>, mid-range <span class=\"caps\">SATA</span> disks, and so on &#8212; a fairly typical commodity system.  Note that this set of tests are not intended to provide useful absolute numbers for either database, but rather to allow some preliminary comparisons between the two. We tried to be as fair as possible. For instance, InnoDB was given an independent disk for its journaling.</p>\n<p>The first comparison was a sequential load into an empty database.  We inserted one hundred million items with numerically-sorted keys, using fairly small values of 100 bytes per item.<br />\n<img src=\"/images/level-inno-1.jpg\">\t\n<br />\nThe database created by this insert test was used as the starting point for all subsequent tests.  Each subsequent test was run in steady-state for one hour on each of the two databases.  Longer runs will be important for us to gauge stability, but an hour per test seemed like a useful starting point.</p>\n<p>For the second comparison, we did a read-only scenario with a pareto distribution. This means that a minority of the items in the database would see the vast majority of requests, which means that there will be relatively high churn but also a higher percentage of cache hits in a typical system.<br />\n<img src=\"/images/level-inno-2.jpg\">\t\n</p>\n<p>The third comparison used exactly the same pareto pattern for key distribution, but instead of being pure reads it was a 90/10 read/write ratio.<br />\n<img src=\"/images/level-inno-3.jpg\">\t\n</p>\n<p>The fourth comparison was intended to see how the two systems compared to each other in a very-high-churn setting. It used the same dataset, but write-only, and in an extremely narrow pareto distribution such that nearly all writes would be within a narrow set of keys, causing a relatively small number of items to be overwritten many times.<br />\n<img src=\"/images/level-inno-4.jpg\">\t\n</p>\n<p>In each of these tests, LevelDB showed a higher throughput than InnoDB and a similar or lower latency than InnoDB. Our goal in this initial round was to explore basic feasibility, and that has now been established.</p>\n<p>This exercise has not been an attempt to provide comprehensive general-purpose benchmarks for either of these two storage engines. A number of choices made do not represent any particular generic usage pattern but were instead made to quickly put the systems under stress and to minimize the number of variables being considered. There are certainly many scenarios where either of these two storage systems can certainly be made to perform differently (sometimes much better) than they did here. In some earlier tests, we saw InnoDB provide a narrower variance of latency (such as lower values in the 99th percentile) but we have not seen that reproduced in this set of tests. Among the other things not done in this quick set of tests: using the storage engines through Riak, deeply examining their I/O behavior, observing their stability over very long periods of time, comparing their response to different concurrency patterns, or comparing them to a wider range of embedded storage engines. All of these directions (and more) are good ideas for continued work in the future, and we will certainly do some of that.</p>\n<p>Despite everything we haven&#8217;t yet done, this early work has validated one early hope and hypothesis. It appears that LevelDB may become a preferred choice for Riak users whose data set has massive numbers of keys and therefore is a poor match with Bitcask&#8217;s model. Performance aside, it compares favorably to InnoDB on other issues such as permissive license and operational usability. We are now going ahead with the work and continued testing needed to keep exploring this hypothesis and to improve both Riak and LevelDB in order to make their combined use an option for our customers and open source community.</p>\n<p>Some issues still remain that we are working to resolve before LevelDB can be a first-class storage engine under Riak. One such issue that we are working on (with the LevelDB maintainers at Google) is making the LevelDB code portable to all of the same platforms that Riak is supported on. We are confident that these issues will be resolved in the very near future. Accordingly, we are moving ahead with a backend enabling Riak&#8217;s use of LevelDB.</p>\n<p><a href=\"https://twitter.com/justinsheehy\">Justin</a></p>",
  "isoTimestamp": "2011-07-01T07:00:00.000Z",
  "_id": "2011-07-01T07:00:00.000Z-basho blog",
  "site": {
    "feed": "http://blog.basho.com/feed/index.xml",
    "author": "Basho Technologies",
    "link": "http://blog.basho.com"
  },
  "displayDate": "Jul 1 2011"
}