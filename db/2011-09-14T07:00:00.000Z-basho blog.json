{
  "entry": "\n   ",
  "title": "Secondary Indexes in Riak",
  "link": "http://blog.basho.com/2011/09/14/Secondary-Indexes-in-Riak",
  "guid": "http://blog.basho.com/2011/09/14/Secondary-Indexes-in-Riak",
  "updated": "2011-09-14T00:00:00+00:00",
  "pubdate": "2011-09-14T07:00:00.000Z",
  "rfc822": "Wed, 14 Sep 2011 00:00:00 -0700",
  "id": "http://blog.basho.com/2011/09/14/Secondary-Indexes-in-Riak",
  "description": "<p><strong>September 14, 2011</strong></p>\n\n<p>Developers building an application on Riak typically have a love/hate\nrelationship with Riak's simple key/value-based approach to storing\ndata. It's great that anyone can grok the basics (3 simple operations,\nget/put/delete) quickly. It's convenient that you can store anything\nimaginable as an object's value: an integer, a blob of JSON data, an\nimage, an MP3. And the distributed, scalable, failure-tolerant\nproperties that a key/value storage model enables can be a lifesaver\ndepending on your use case.</p>\n\n<p>But things get much less rosy when faced with the challenge of\nrepresenting alternate keys, one-to-many relationships, or\nmany-to-many relationships in Riak. Historically, Riak has shifted\nthese responsibilities to the application developer. The developer is\nforced to either find a way to fit their data into a key/value model,\nor to adopt a polyglot storage strategy, maintaining data in one\nsystem and relationships in another.</p>\n\n<p>This adds complexity and technical risk, as the developer is burdened\nwith writing additional bookkeeping code and/or learning and\nmaintaining multiple systems.</p>\n\n<p>That's why we're so happy about Secondary Indexes. Secondary Indexes\nare the first step toward solving these challenges, lifting the burden\nfrom the backs of developers, and enabling more complex data modeling\nin Riak. And the best part is that it ships in our 1.0 release, just a\nfew weeks from now.</p>\n\n<h2>How Do Secondary Indexes Work?</h2>\n\n<p>From an application developer's perspective, Secondary Indexes allow\nyou to tag a Riak object with some index metadata, and later retrieve\nthe object by querying the index, rather than the object's primary\nkey.</p>\n\n<p>For example, let's say you want to store a user object, accessible by\nusername, twitter handle, or email address. You might pick the\nusername as the primary key, while indexing the twitter handle and\nemail address. Below is a curl command to accomplish this through the\nHTTP interface of a local Riak node:</p>\n\n<pre><code>curl -X POST \\\n-H 'x-riak-index-twitter_bin: rustyio' \\\n-H 'x-riak-index-email_bin: rusty@basho.com' \\\n-d '...user data...' \\\nhttp://localhost:8098/buckets/users/keys/rustyk\n</code></pre>\n\n<p>Previously, there was no simple way to access an object by anything\nother than the primary key, the username. The developer would be\nforced to \"roll their own indexes.\" With Secondary Indexes enabled,\nhowever, you can easily retrieve the data by querying the user's\ntwitter handle:</p>\n\n<pre><code> # Query the twitter handle...\n curl localhost:8098/buckets/users/index/twitter_bin/rustyio\n\n # Response...\n {\"keys\":[\"rustyk\"]}\n</code></pre>\n\n<p>Or the user's email address:</p>\n\n<pre><code> # Query the email address...\n curl localhost:8098/buckets/users/index/email_bin/rusty@basho.com\n\n # Response...\n {\"keys\":[\"rustyk\"]}\n</code></pre>\n\n<p>You can change an object's indexes by simply writing the object again\nwith the updated index information. For example, to add an index on\nGithub handle:</p>\n\n<pre><code>curl -X POST \\\n-H 'x-riak-index-twitter_bin: rustyio' \\\n-H 'x-riak-index-email_bin: rusty@basho.com' \\\n-H 'x-riak-index-github_bin: rustyio' \\\n-d '...user data...' \\\nhttp://localhost:8098/buckets/users/keys/rustyk\n</code></pre>\n\n<p>That's all there is to it, but that's enough to represent a variety of\ndifferent relationships within Riak.</p>\n\n<p>Above is an example of assigning an alternate key to an object. But\nimagine that instead of a <code>twitter_bin</code> field, our object had an\n<code>employer_bin</code> field that matched the primary key for an object in our\n<code>employers</code> bucket. We can now look up users by their employer.</p>\n\n<p>Or imagine a <code>role_bin</code> field that matched the primary key for an\nobject in our <code>security_roles</code> bucket. This allows us to look up all\nusers that are assigned to a specific security role in the system.</p>\n\n<h2>Design Decisions</h2>\n\n<p>Secondary Indexes maintains Riak's distributed, scalable, and failure\ntolerant nature by avoiding the need for a pre-defined schema, which\nwould be shared state. Indexes are declared on a per-object basis, and\nthe index type (binary or integer) is determined by the field's\nsuffix.</p>\n\n<p>Indexing is real-time and atomic; the results show up in queries\nimmediately after the write operation completes, and all indexing\noccurs on the\n<a href=\"http://wiki.basho.com/Riak-Glossary.html#Partition\">partition</a> where\nthe object lives, so the object and its indexes stay in sync. Indexes\ncan be stored and queried via the HTTP interface or the Protocol\nBuffers interface. Additionally, index results can feed directly into\na Map/Reduce operation. And our Enterprise customers will be happy to\nknow that Secondary Indexing plays well with multi data center\nreplication.</p>\n\n<p>Indexes are declared as metadata, rather than an object's value, in\norder to preserve Riak's view that the value of your object is as an\nopaque document. An object can have an unlimited number of index\nfields of any size (dependent upon system resources, of course.) We\nhave stress tested with 1,000 index fields, though we expect most\napplications won't need nearly that many. Indexes do contribute to the\nbase size of the object, and they also take up their own disk space,\nbut the overhead for each additional index entry is minimal: the\n<a href=\"http://wiki.basho.com/Riak-Glossary.html#Vector-Clock\">vector clock</a>\ninformation (and other metadata) is stored in the object, not in the\nindex entry. Additionally, the LevelDB backend (and, likely, most\nindex-capable backends) support prefix-compression, further shrinking\nindex size.</p>\n\n<p>This initial release does have some important limitations. Only single\nindex queries are supported, and only for exact matches or range\nqueries. The result order is undefined, and pagination is not\nsupported. While this offers less in the way of ad-hoc querying than\nother datastores, it is a solid 80% solution that allows us to focus\nfuture energy where users and customers need it most. (Trust me, we\nhave many plans and prototypes of potential features. Building\nsomething is easy, building the <strong>right</strong> thing is harder.)</p>\n\n<h2>Behind The Scenes</h2>\n\n<p>What is happening behind the scenes? A lot, actually.</p>\n\n<p>At <em>write time</em>, the system pulls the index fields from the incoming\nobject, parses and validates the fields, updates the object with the\nnewly parsed fields, and then continues with the write operation. The\nreplicas of the object are sent to\n<a href=\"http://wiki.basho.com/Riak-Glossary.html#Vnode\">virtual nodes</a> where\nthe object and its indexes are persisted to disk.</p>\n\n<p>At <em>query time</em>, the system first calculates what we call a \"covering\"\nset of partitions. The system looks at how many replicas of our data\nare stored and determines the minimum number of partitions that it\nmust examine to retrieve a full set of results, accounting for any\noffline nodes. By default, Riak is configured to store 3 replicas of\nall objects, so the system can generate a full result set if it reads\nfrom one-third of the system's partitions, as long as it chooses the\nright set of partitions. The query is then broadcast to the selected\npartitions, which read the index data, generate a list of keys, and\nsend them back to the coordinating node.</p>\n\n<p>Storing index data is very different from storing key/value data: in\ngeneral, any database that stores indexes on a disk would <em>prefer</em> to\nbe able to store the index in a contiguous block and in the desired\norder--basically getting as near to the final result set as\npossible. This minimizes disk movement and other work during a query,\nand provides faster read operations. The challenge is that index\nvalues rarely enter the system in the right order, so the database\nmust do some shuffling at write time. Most databases delay this\nshuffling, they write to disk in a slightly sub-optimal format, then\ngo back and \"fix things up\" at a later point in time.</p>\n\n<p>None of Riak's existing key/value-oriented backends were a good fit\nfor index data; they all focused on fast key/value access. During the\ndevelopment of Secondary Indexes we explored other\noptions. Coincidentally, the Basho team had already begun work to\nadapt LevelDB--a low-level storage library from Google--as a storage\nengine for Riak KV. LevelDB stores data in a defined order, exactly\nwhat Secondary Indexes needed, and it is actually versatile enough to\nmanage both the index data AND the object's value. Plus, it is very\nRAM friendly. You can learn more about LevelDB from\n<a href=\"http://code.google.com/p/leveldb/\">this page</a> on Google Code.</p>\n\n<h2>Want To Know More?</h2>\n\n<p>If you want to learn more about Secondary Indexes, you can read the\nslides from my talk at OSCON Data 2011:\n<a href=\"http://www.slideshare.net/rklophaus/querying-riak-just-got-easier-introducing-secondary-indices\">Querying Riak Just Got Easier</a>. Alternatively,\nyou can <a href=\"http://www.youtube.com/watch?v=uExMXa4t8eg\">watch the video</a>.</p>\n\n<p>You can grab a pre-release version of Riak Version 1.0 on the\n<a href=\"http://downloads.basho.com/riak/\">Basho downloads site</a> to try the\nexamples above. Remember to change the storage backend to\n<code>riak_kv_eleveldb_backend</code>!</p>\n\n<p>Finally keep an eye out for documentation that will land on the newly\nre-organized <a href=\"http://wiki.basho.com\">Basho Wiki</a> within the next two\nweeks.</p>\n\n<p>-- <a href=\"http://twitter.com/rustyio\">Rusty</a></p>\n",
  "isoTimestamp": "2011-09-14T07:00:00.000Z",
  "_id": "2011-09-14T07:00:00.000Z-basho blog",
  "site": {
    "feed": "http://blog.basho.com/feed/index.xml",
    "author": "Basho Technologies",
    "link": "http://blog.basho.com"
  },
  "displayDate": "Sep 14 2011"
}