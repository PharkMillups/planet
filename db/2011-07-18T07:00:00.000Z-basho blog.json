{
  "entry": "\n   ",
  "title": "Boosting Riak Search Query Performance With Inline Fields",
  "link": "http://blog.basho.com/2011/07/18/Boosting-Riak-Search-Query-Performance-With-Inline-Fields",
  "guid": "http://blog.basho.com/2011/07/18/Boosting-Riak-Search-Query-Performance-With-Inline-Fields",
  "updated": "2011-07-18T00:00:00+00:00",
  "pubdate": "2011-07-18T07:00:00.000Z",
  "rfc822": "Mon, 18 Jul 2011 00:00:00 -0700",
  "id": "http://blog.basho.com/2011/07/18/Boosting-Riak-Search-Query-Performance-With-Inline-Fields",
  "description": "<p><strong>July 18, 2011</strong></p>\n\n<p>(<em>This was originally posted on <a href=\"http://twitter.com/#!/rzezeski\">Ryan Zezeski's</a> working blog \"<a href=\"https://github.com/rzezeski/try-try-try/tree/master/2011/riak-search-inline-fields\">Try Try Try</a>\"</em>)</p>\n\n<p>In this post I want to give a quick overview of <em>inline fields</em>, a recent addition to <a href=\"http://wiki.basho.com/Riak-Search---Schema.html#Fields-and-Field-Level-Properties\">Riak Search</a> that allows you to trade-off disk space for a considerable performance bump in query execution and throughput.  I'm going to assume the reader is already familiar with <a href=\"http://wiki.basho.com/Riak-Search.html\">Search</a>. In the future I may do a Search overview.  If you would like that then ping me on <a href=\"http://twitter.com/#!/rzezeski\">twitter</a>.</p>\n\n<h2>The Goal</h2>\n\n<p>Recently on the\n<a href=\"http://lists.basho.com/mailman/listinfo/riak-users_lists.basho.com\">Riak Users Mailing List</a>\nthere was a discussion about improving the performance of Search when\nexecuting intersection (i.e. <code>AND</code>) queries where one term has a low\nfrequency and the other has a high frequency.  This can pose a problem\nbecause Search needs to run through all the results on both sides in\norder to provide the correct result.  Therefore, the query is always\nbounded by the highest frequency term.  This is exasperated further by\nthe fact that Search uses a <em>global index</em>, or in other words\npartitions the index by term.  This effectively means that all results\nfor a particular term are pulled sequentially from <strong>one</strong> node.  This\nis opposed to a <em>local index</em>, or partitioning by document, which\neffectively allows you to parallelize the query across all nodes.\nThere are trade-offs for either method and I don't want to discuss\nthem in this blog post.  However, it's good to keep in mind\n<sup>1</sup>. My goal with this post is to show how you can improve\nthe performance of this type of query with the current version of\nSearch <sup>2</sup>.</p>\n\n<h2>What's an \"Inline\" Field, Anyways?</h2>\n\n<p>To properly understand inline fields you need to understand the\n<em>inverted index</em> data structure <sup>3</sup>.  As a quick refresher\nthe gist is that the index is a map from words to a list of document\nreference/weight pairs.  For each word <sup>4</sup> the index tells\nyou in which documents it occurs and its \"weight\" in relation to that\ndocument, e.g. how many times it occurs.  Search adds a little twist\nto this data structure by allowing an arbitrary list of properties to\nbe tacked onto each of these pairs.  For example, Search tracks the\nposition of each occurrence of a term in a document.</p>\n\n<p>Inline fields allow you to take advantage <sup>5</sup> of this fact\nand store the terms of a field directly in the inverted index entries\n<sup>6</sup>.  Going back to my hypothetical query you could mark the\nfield with the frequently occurring term as <code>inline</code> and change the\n<code>AND</code> query to a query and a <em>filter</em>.  A filter is simply an extra\nargument to the Search API that uses the same syntax as a regular\nquery but makes use of the inline field.  This has the potential to\ndrop your latency dramatically as you avoid pulling the massive\n<em>posting</em> <sup>7</sup> altogether.</p>\n\n<p><strong>WARNING: Inline fields are not free!  Think carefully about what I\n just described and you'll realize that this list of inline terms will\n be added to every single posting for that index.  If your field\n contains many terms or you have many inline fields this could become\n costly in terms of disk space.  As always, benchmarking with real\n hardware on a real production data set is recommended.</strong></p>\n\n<h2>The Corpus</h2>\n\n<p>I'll be using a set of ~63K <a href=\"http://www.infochimps.com/datasets/twitter-haiti-earthquake-data\">tweets</a> that occurred in reaction\nto the the devastating earthquake that took place in Haiti during\nJanuary of 2010.  The reason I choose this data-set is because it's\nguaranteed to have frequently occurring terms such as \"earthquake\" but\nalso has low occurring terms <sup>7</sup> such as the time the tweets\nwere created.</p>\n\n<h2>The Rig</h2>\n\n<p>All benchmarks were run on a 2GHz i7 MBP with an SSD <sup>8</sup>.  An\ninitial run is performed to prime all systems.  Essentially,\neverything should be coming from FS cache meaning I'll mostly be\ntesting processing time.  My guess is disk I/O would only amplify the\nresults.  I'll be using Basho Bench and running it on the same machine\nas my cluster.  My cluster consists of four Riak nodes (obviously,\non the same machine) which I built from master <sup>9</sup>.</p>\n\n<p>If you'd like to run the benchmarks on your own hardware please see\nthe <a href=\"https://github.com/rzezeski/try-try-try/blob/master/2011/riak-search-inline-fields/RUN_BENCHMARKS.md\">RUN_BENCHMARKS.md</a>\nfile.</p>\n\n<h2>Naive Query</h2>\n\n<pre><code>\"text:earthquake\"\n</code></pre>\n\n<p>The naive query asks for every document id <sup>10</sup> that includes\nthe word <code>earthquake</code>.  This should return <code>62805</code> results every time.</p>\n\n<p><img src=\"https://github.com/rzezeski/try-try-try/raw/master/2011/riak-search-inline-fields/results/naive.png\" alt=\"Naive\" /></p>\n\n<h2>Scoped Query</h2>\n\n<pre><code>\"text:earthquake AND created_at:[20100113T032200 TO 20100113T032500]\"\n</code></pre>\n\n<p>The scoped query still searches for all documents with the term\n<code>earthquake</code> but restricts this set further to only those that were\ncreated in the provided three minute time span.</p>\n\n<p><img src=\"https://github.com/rzezeski/try-try-try/raw/master/2011/riak-search-inline-fields/results/scoped.png\" alt=\"Scoped\" /></p>\n\n<h2>Scoped Query With Filtering</h2>\n\n<pre><code>\"created_at:[20100113T032200 TO 20100113T032500]\" \"text:earthquake\"\n</code></pre>\n\n<p>This is the same as the scoped query except <code>earthquake</code> is now a\nfilter, not a query.  Notice, unlike the previous two queries, there\nare two strings.  The first is the query the second is the filter.\nYou could read that in English as:</p>\n\n<blockquote><p>Execute the query to find all tweets created in this three minute\nrange.  Then filter that set using the inline field \"text\" where it\ncontains the term \"earthquake.\"</p></blockquote>\n\n<p><img src=\"https://github.com/rzezeski/try-try-try/raw/master/2011/riak-search-inline-fields/results/scoped-filter.png\" alt=\"Scoped &amp; Filter\" /></p>\n\n<h2>Wait One Second!</h2>\n\n<p>Just before I was about to consider this post wrapped up I realized my\ncomparison of inline vs. non-inline wasn't quite fair.  As currently\nimplemented, when returning postings the inline field's value is\nincluded.  I'm not sure if this is of any practical use outside the\nfiltering mechanism but this means that in the case of the naive and\nscoped queries the cluster is taking an additional disk and network\nhit by carrying all that extra baggage.  A more fair comparison would\nbe to run the naive and scoped queries with no inline fields.  I\nadjusted my scripts and did just that.</p>\n\n<h3>Naive With No Inlining</h3>\n\n<p><img src=\"https://github.com/rzezeski/try-try-try/raw/master/2011/riak-search-inline-fields/results/naive-non-inline.jpg\" alt=\"Naive No Inline\" /></p>\n\n<h3>Scoped With No Inlining</h3>\n\n<p><img src=\"https://github.com/rzezeski/try-try-try/raw/master/2011/riak-search-inline-fields/results/scoped-non-inline.jpg\" alt=\"Scoped No Inline\" /></p>\n\n<h2>Conclusions</h2>\n\n<p>In this first table I summarize the absolute values for throughput,\n99.9th percentile and average latencies.</p>\n\n<table>\n  <tr>\n    <th>Stat</th>\n    <th>Naive (I)</th>\n    <th>Naive</th>\n    <th>Scoped (I)</th>\n    <th>Scoped</th>\n    <th>Scoped Filter</th>\n  </tr>\n\n  <tr>\n    <td>Thru (op/s)</td>\n    <td>2.5</td>\n    <td>3.5</td>\n    <td>3</td>\n    <td>5</td>\n    <td>15</td>\n  </tr>\n  \n  <tr>\n    <td>99.9% (ms)</td>\n    <td>875</td>\n    <td>490</td>\n    <td>575</td>\n    <td>350</td>\n    <td>42</td>\n  </tr>\n  \n  <tr>\n    <td>Avg (ms)</td>\n    <td>800</td>\n    <td>440</td>\n    <td>530</td>\n    <td>310</td>\n    <td>25</td>\n  </tr>\n</table>\n\n\n<p>In this benchmark I don't care so much about the absolute numbers as I\ndo how they relate to each other.  In the following table I show the\nperformance increase of using the scoped filter query versus the other\nqueries.  For example, the scoped filter query has three times the\nthroughput and returns in 1/12th of the time, on average, as compared\nto the scoped query.  That is, even its closest competitor has a\nlatency profile that is an order of magnitude worse.  You may find it\nodd that I included the naive queries in this comparison but I wanted\nto show just how great the difference can be when you don't limit your\nresult set.  Making a similar table comparing naive vs. scoped might\nbe useful as well but I leave it as an exercise to the reader.</p>\n\n<table>\n  <tr>\n    <th>Stat</th>\n    <th>Naive (I)</th>\n    <th>Naive</th>\n    <th>Scoped (I)</th>\n    <th>Scoped</th>\n  </tr>\n  \n  <tr>\n    <td>Thru</td>\n    <td>6x</td>\n    <td>4x</td>\n    <td>5x</td>\n    <td>3x</td>\n  </tr>\n\n  <tr>\n    <td>99.9%</td>\n    <td>20x</td>\n    <td>11x</td>\n    <td>13x</td>\n    <td>8x</td>\n  </tr>\n\n  <tr>\n    <td>Avg</td>\n    <td>32x</td>\n    <td>17x</td>\n    <td>21x</td>\n    <td>12x</td>\n  </tr>\n</table>\n\n\n<p>In conclusion I've done a drive-by benchmark showing that there are\npotentially great gains to be had by making use of inline fields.  I\nsay \"potentially\" because inline fields are not free and you should\ntake the time to understand your data-set and analyze what trade-offs\nyou might be making by using this feature.  In my example I'm inlining\nthe text field of a twitter stream so it would be useful to gather\nsome statistics such as what are the average number of terms per tweet\nand what is the average size of each term?  Armed with that info you\nthen might determine how many tweets you plan to store, how many\nresults a typical query will match and how much extra I/O overhead\nthat inline field is going to add.  Finally, run your own benchmarks\non your own hardware with real data while profiling your system's I/O,\nCPU, and memory usage.  Doing anything else is just pissing in the\nwind.</p>\n\n<p><a href=\"http://twitter.com/#!/rzezeski\">Ryan</a></p>\n\n<h2>References</h2>\n\n<p>1: If you'd like to know more you could start by reading <a href=\"http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.86.7337\">Distributed\nQuery Processing Using Partitioned Inverted Files</a>.</p>\n\n<p>2: Inline fields were added in 14.2, but my benchmarks were run\nagainst master.</p>\n\n<p>3: I like the introduction in <a href=\"http://research.yahoo.com/pub/2219\">Effect of Inverted Index Partitioning\nSchemes on Performance of Query Processing in Parallel Text Retrieval\nSystems</a>.</p>\n\n<p>4: In search parlance a word is called a <em>term</em> and the entire list of\nterms is called the <em>vocabulary</em>.</p>\n\n<p>5: Or abuse, depending on your disposition.</p>\n\n<p>6: Entries in an inverted index are also called <em>postings</em> by some\npeople.</p>\n\n<p>7: Or high cardinality, depending on how you want to look at it.</p>\n\n<p>8: Just like when dynoing a car it's constant conditions and relative\nimprovement that matter.  Once you're out of the shop those absolute\nnumbers don't mean much.</p>\n\n<p>9: The exact commit is <code>3cd22741bed9b198dc52e4ddda43579266a85017</code>.</p>\n\n<p>10: BTW, in this case \"document\" is a Riak object indexed by the\nSearch Pre-commit hook.</p>\n",
  "isoTimestamp": "2011-07-18T07:00:00.000Z",
  "_id": "2011-07-18T07:00:00.000Z-basho blog",
  "site": {
    "feed": "http://blog.basho.com/feed/index.xml",
    "author": "Basho Technologies",
    "link": "http://blog.basho.com"
  },
  "displayDate": "Jul 18 2011"
}